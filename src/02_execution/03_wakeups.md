# タスクを起こせ！Waker！

`Future`は最初に`poll`された時に完了できないことがよくあります。これが発生した時、`Future`はさらに前進する準備ができたら再度ポーリングされるようにする必要があります。
これは`Waker`型で行われます。

`Future`がポーリングされるたびに、「タスク」の一部としてポーリングされます。
タスクは、エグゼキューターに送信されたトップレベルの`Future`です。

`Waker`は関連付けられたタスクを起動する必要があることをエグゼキューターに伝えるために使用できる`wake()`メソッドを提供します。

`wake()`が呼び出された時、エグゼキューターは、`Waker`と関連するタスクが進む準備が出来たことを知っています。そして、再びポーリングする必要があることも。

`Waker`は`clone()`も実装しているため、コピーして保存することが出来ます。

`Waker`を使用して単純なタイマーを実装してみましょう！

## タイマー作成

この例では、タイマーが作成された時に新しいスレッドを立て、必要な時間だけスリープし、時間経過した時にタイマーの`Future`を通知します。

必要なインポートは次のとおりです。

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:imports}}
```

`Future`の型自体を定義するところからです。私達のfutureにはスレットが、タイマーが経過し、futureが完了するべきであることを伝える方法が必要です。 `Arc<Mutex<..>>`を使用して、スレッドとfutureの間で通信します。

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:timer_decl}}
```

実際に`Future`の実装を書いていきましょ！

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:future_for_timer}}
```

かなり簡単ですね。スレッドに`shared_state.completed = true`が設定されている時、完了です！ それ以外の場合`Waker`は現在のタスクのクローンを作成して`shared_state.waker`に渡し、スレッドがタスクを復帰できるようにします。

重要なのは、futureが異なる`Waker`を持つ異なるタスクに移動した可能性があるため、futureがポーリングされるたびに`Waker`を更新する必要があることです。これは、ポーリングされたあと、タスク間でfutureが渡される時に発生します。

最後に、実際にタイマーを構築してスレッドを開始するAPIが必要です。

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:timer_new}}
```

すげぇ！単純なタイマーのfutureを構築するために必要なのはそれだけです。
さて、futureを実行するエグゼキューターがいれば、、、
